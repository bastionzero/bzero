package authorizedkeys

import (
	"bufio"
	"bytes"
	"encoding/base64"
	"errors"
	"fmt"
	"io/fs"
	"os"
	"os/user"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
	"time"

	"bastionzero.com/bctl/v1/bzerolib/filelock"
	"bastionzero.com/bctl/v1/bzerolib/logger"
)

const (
	authorizedKeyComment         = "bzero-temp-key"
	lockFileName                 = ".bzero.lock"
	authorizedKeyFileName        = "authorized_keys"
	authorizedKeysFilePermission = 0600 // only owner (user) can read/write
)

type AuthorizedKeys struct {
	logger   *logger.Logger
	doneChan chan struct{}

	keyLifetime time.Duration

	usr *user.User

	keyFilePath string
	fileLock    *filelock.FileLock
}

func New(logger *logger.Logger, username string, doneChan chan struct{}, authKeyFolder string, lockFileFolder string, keyLifetime time.Duration) (*AuthorizedKeys, error) {

	if err := validateUsername(username); err != nil {
		return nil, err
	}

	usr, err := user.Lookup(username)
	if err != nil {
		return nil, fmt.Errorf("failed to determine whether user exists: %s", err)
	} else if usr.HomeDir == "" {
		return nil, fmt.Errorf("cannot connect as user without home directories")
	}

	authKey := &AuthorizedKeys{
		logger:      logger,
		doneChan:    doneChan,
		keyLifetime: keyLifetime,
		usr:         usr,
	}

	if err := authKey.setKeyFilePath(usr.HomeDir, authKeyFolder); err != nil {
		return nil, err
	} else if err := authKey.setFileLock(usr.HomeDir, lockFileFolder); err != nil {
		return nil, err
	} else {
		return authKey, nil
	}
}

func (a *AuthorizedKeys) Add(pubkey string) error {
	// build authorized key entry in the right format then add it to the file
	if entry, err := a.buildAuthorizedKey(pubkey); err != nil {
		return err
	} else if err := a.addKeyToFile(entry); err != nil {
		return fmt.Errorf("failed to add key to authorized_keys file: %s", err)
	} else {

		// remove the key since it's ephemeral
		go func() {
			select {
			case <-a.doneChan:
				a.logger.Infof("Detected a closed done chan, cleaning authorized keys file")
			case <-time.After(a.keyLifetime):
				a.logger.Infof("SSH key expired, cleaning authorized keys file")
			}

			if err := a.cleanAuthorizedKeys(entry); err != nil {
				a.logger.Errorf("Failed to remove old keys from %s: %s", a.keyFilePath, err)
			}
		}()
	}

	return nil
}

func (a *AuthorizedKeys) buildAuthorizedKey(pubkey string) (string, error) {
	// Construct the authorized key entry
	// Assumes for now only ssh-rsa key types will be generated by the client so we do not need to validate the key type
	keyData := strings.Fields(pubkey)
	if len(keyData) < 2 {
		return "", fmt.Errorf("malformed public key")
	}

	keyType := keyData[0]
	keyContents := keyData[1]

	// test that the provided public key is valid base64 data
	if _, err := base64.StdEncoding.DecodeString(keyContents); err != nil {
		return "", fmt.Errorf("invalid public key provided: %s", keyContents)
	}

	timestamp := time.Now().UnixNano()
	key := fmt.Sprintf("%s %s %s created_at=%d", keyType, keyContents, authorizedKeyComment, timestamp)
	return key, nil
}

func (a *AuthorizedKeys) addKeyToFile(contents string) error {
	// wait to acquire a lock on the authorized_keys file
	lock, err := a.fileLock.NewLock()
	if err != nil {
		return fmt.Errorf("failed to obtain lock: %s", err)
	}
	for {
		if acquiredLock, err := lock.TryLock(); err != nil {
			return fmt.Errorf("error acquiring lock: %s", err)
		} else if acquiredLock {
			break
		}
	}

	defer lock.Unlock()

	file, err := a.openAuthorizedKeys()
	if err != nil {
		return err
	}
	defer file.Close()

	// make sure we're always writing our keys to new lines
	if fileBytes, err := os.ReadFile(a.keyFilePath); err != nil {
		return err
	} else if len(fileBytes) > 0 && !strings.HasSuffix(string(fileBytes), "\n") {
		contents = "\n" + contents
	}

	if _, err := file.WriteString(contents); err != nil {
		return err
	}

	return nil
}

func (a *AuthorizedKeys) openAuthorizedKeys() (*os.File, error) {
	// check if file exists
	if _, err := os.Stat(a.keyFilePath); errors.Is(err, fs.ErrNotExist) {
		// check permissions to create file
		if ok, err := checkPermissionToCreate(filepath.Dir(a.keyFilePath), a.usr); !ok {
			return nil, fmt.Errorf("failed create permissions check for %s: %s", filepath.Dir(a.keyFilePath), err)
		} else if err := os.WriteFile(a.keyFilePath, []byte{}, authorizedKeysFilePermission); err != nil { // create file
			return nil, fmt.Errorf("unable to create authorized_keys file %s: %s", a.keyFilePath, err)
		} else if err := setFileOwner(a.keyFilePath, a.usr); err != nil {
			return nil, err
		}
	} else if err != nil {
		return nil, fmt.Errorf("failed to check whether path %s exists: %s", a.keyFilePath, err)
	} else {
		// check if we have permission to write to file
		if ok, err := checkPermissionToWrite(a.keyFilePath, a.usr); !ok {
			return nil, fmt.Errorf("failed write permissions check for %s: %s", a.keyFilePath, err)
		}
	}

	return os.OpenFile(a.keyFilePath, os.O_APPEND|os.O_WRONLY, 0644)
}

func (a *AuthorizedKeys) cleanAuthorizedKeys(currentKey string) error {
	// wait to acquire a lock on the authorized_keys file
	lock, err := a.fileLock.NewLock()
	if err != nil {
		return fmt.Errorf("failed to obtain lock: %s", err)
	}
	for {
		if acquiredLock, err := lock.TryLock(); err != nil {
			return fmt.Errorf("error acquiring lock: %s", err)
		} else if acquiredLock {
			break
		}
	}

	defer lock.Unlock()

	// read the authorized key file
	fileBytes, err := os.ReadFile(a.keyFilePath)
	if err != nil {
		return fmt.Errorf("failed to read from authorized_keys file \"%s\": %s", a.keyFilePath, err)
	}

	// iterate over the lines in our file, each line presents a new authorized_key entry
	newFileBytes := []byte{}
	scanner := bufio.NewScanner(bytes.NewReader(fileBytes))
	for scanner.Scan() {
		key := scanner.Text()

		// remove it if it's our current key, even if it's unexpired
		if key == currentKey {
			continue
		} else if strings.Contains(key, authorizedKeyComment) && strings.Contains(key, "created_at=") {
			// parse our creation time
			creationTimeString := strings.Split(strings.Split(key, "created_at=")[1], " ")[0]
			if creationTimeInt, err := strconv.ParseInt(creationTimeString, 10, 64); err != nil {
				// By returning here, we are opting not to overwrite the file at all.
				// This potentially leaves it around for longer but mitigates the risk of accidentally erasing something important
				return fmt.Errorf("malformated unix time")
			} else {
				unixCreationTime := time.Unix(0, creationTimeInt)

				// if the key is expired, remove it
				if time.Since(unixCreationTime) >= a.keyLifetime {
					continue
				}
			}
		}

		// scanner.Scan removed new line so we add that back in
		newLine := append(scanner.Bytes(), "\n"...)
		newFileBytes = append(newFileBytes, newLine...)
	}

	if err := scanner.Err(); err != nil {
		return err
	}

	// we don't need to check permissions here, because it's the process's responsibility
	// to clean the authorized_keys file
	if err := os.WriteFile(a.keyFilePath, newFileBytes, authorizedKeysFilePermission); err != nil {
		return err
	}
	return nil
}

// test that the provided username is valid unix user name
// source: https://unix.stackexchange.com/a/435120
func validateUsername(username string) error {
	usernamePattern := "^[a-z_]([a-z0-9_-]{0,31}|[a-z0-9_-]{0,30}\\$)$"
	var usernameMatch, _ = regexp.MatchString(usernamePattern, username)
	if !usernameMatch {
		return fmt.Errorf("invalid username provided: %s", username)
	}
	return nil
}

// validate that the user has a home directory, drop down to their permissions, and create authorized_keys if not exists
func (a *AuthorizedKeys) setKeyFilePath(homeDir string, keyFolder string) error {
	path := filepath.Join(homeDir, keyFolder)

	// check if directory exists
	if _, err := os.Stat(path); errors.Is(err, fs.ErrNotExist) {
		// check if we have permission to create directory
		if ok, err := checkPermissionToCreate(homeDir, a.usr); !ok {
			return fmt.Errorf("failed create permissions check for %s: %s", homeDir, err)
		} else if err := os.Mkdir(path, 0700); err != nil {
			return fmt.Errorf("failed to create %s/%s/: %s", homeDir, keyFolder, err)
		} else if err := setFileOwner(path, a.usr); err != nil {
			return err
		}
	} else if err != nil {
		return fmt.Errorf("failed to check whether path %s exists: %s", path, err)
	}

	a.keyFilePath = filepath.Join(path, authorizedKeyFileName)
	return nil
}

func (a *AuthorizedKeys) setFileLock(homeDir string, lockFileFolder string) error {
	if err := os.MkdirAll(filepath.Join(homeDir, lockFileFolder), os.ModePerm); err != nil {
		return fmt.Errorf("failed to create %s/%s/: %s", homeDir, lockFileFolder, err)
	} else {
		a.fileLock = filelock.NewLockService(filepath.Join(homeDir, lockFileFolder, lockFileName))
		return nil
	}
}

func setFileOwner(filepath string, usr *user.User) error {
	if uid, err := strconv.Atoi(usr.Uid); err != nil {
		return fmt.Errorf("failed to convert user string UID to int: %s", err)
	} else if gid, err := strconv.Atoi(usr.Gid); err != nil {
		return fmt.Errorf("failed to convert user string GID to int: %s", err)
	} else if err := os.Chown(filepath, uid, gid); err != nil { // change owner of file to user
		return fmt.Errorf("failed to set user %s as authorized_key owner", usr.Username)
	}
	return nil
}
