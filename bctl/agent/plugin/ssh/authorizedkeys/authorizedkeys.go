package authorizedkeys

import (
	"bufio"
	"bytes"
	"encoding/base64"
	"fmt"
	"os"
	"os/user"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
	"time"

	"bastionzero.com/bctl/v1/bzerolib/logger"
	"bastionzero.com/bctl/v1/bzerolib/services/lockservice"
)

var (
	authorizedKeyFolder   = ".ssh"
	authorizedKeyFileName = "authorized_keys"
)

const (
	authorizedKeyComment = "bzero-temp-key"
)

type AuthorizedKeysInterface interface {
	Add(pubkey string) error
}

type AuthorizedKeys struct {
	logger      *logger.Logger
	user        string
	doneChan    chan struct{}
	lockService lockservice.LockService
	keyLifetime time.Duration
}

func New(logger *logger.Logger, user string, doneChan chan struct{}, lockService lockservice.LockService, keyLifetime time.Duration) *AuthorizedKeys {
	return &AuthorizedKeys{
		logger:      logger,
		user:        user,
		doneChan:    doneChan,
		lockService: lockService,
		keyLifetime: keyLifetime,
	}
}

func (a *AuthorizedKeys) Add(pubkey string) error {
	// build authorized key entry in the right format then add it to the file
	if entry, err := a.buildAuthorizedKey(pubkey); err != nil {
		return err
	} else if filePath, err := a.buildFilePath(); err != nil {
		return err
	} else if err := a.addKeyToFile(filePath, entry); err != nil {
		return fmt.Errorf("failed to add key to authorized_keys file: %s", err)
	} else {

		// remove the key since it's ephemeral
		go func() {
			select {
			case <-a.doneChan:
				a.logger.Infof("Detected a closed done chan, cleaning authorized keys file")
			case <-time.After(a.keyLifetime):
				a.logger.Infof("SSH key expired, cleaning authorized keys file")
			}

			if err := a.cleanAuthorizedKeys(filePath, entry); err != nil {
				a.logger.Errorf("Failed to remove old keys from %s's authorized_keys file: %s", a.user, err)
			}
		}()
	}

	return nil
}

func (a *AuthorizedKeys) buildFilePath() (string, error) {
	// test that the provided username is valid unix user name
	// source: https://unix.stackexchange.com/a/435120
	usernamePattern := "^[a-z_]([a-z0-9_-]{0,31}|[a-z0-9_-]{0,30}\\$)$"
	var usernameMatch, _ = regexp.MatchString(usernamePattern, a.user)
	if !usernameMatch {
		return "", fmt.Errorf("invalid username provided: %s", a.user)
	}

	if usr, err := user.Lookup(a.user); err != nil {
		return "", fmt.Errorf("failed to determine whether user exists: %s", err)
	} else if usr.HomeDir == "" {
		return "", fmt.Errorf("cannot connect as user without home directories")
	} else if err := os.MkdirAll(filepath.Join(usr.HomeDir, authorizedKeyFolder), os.ModePerm); err != nil {
		return "", fmt.Errorf("failed to create %s/%s/: %s", usr.HomeDir, authorizedKeyFolder, err)
	} else {
		return filepath.Join(usr.HomeDir, authorizedKeyFolder, authorizedKeyFileName), nil
	}
}

func (a *AuthorizedKeys) buildAuthorizedKey(pubkey string) (string, error) {
	// Construct the authorized key entry
	// Assumes for now only ssh-rsa key types will be generated by the client so we do not need to validate the key type
	keyData := strings.Fields(pubkey)
	if len(keyData) < 2 {
		return "", fmt.Errorf("malformed public key")
	}

	keyType := keyData[0]
	keyContents := keyData[1]

	// test that the provided public key is valid base64 data
	if _, err := base64.StdEncoding.DecodeString(keyContents); err != nil {
		return "", fmt.Errorf("invalid public key provided: %s", keyContents)
	}

	timestamp := time.Now().UnixNano()
	key := fmt.Sprintf("%s %s %s created_at=%d", keyType, keyContents, authorizedKeyComment, timestamp)
	return key, nil
}

func (a *AuthorizedKeys) cleanAuthorizedKeys(filePath string, currentKey string) error {
	// wait to acquire a lock on the authorized_keys file
	lock, err := a.lockService.NewLock()
	if err != nil {
		return fmt.Errorf("failed to obtain lock: %s", err)
	}
	for {
		if acquiredLock, err := lock.TryLock(); err != nil {
			return fmt.Errorf("error acquiring lock: %s", err)
		} else if acquiredLock {
			break
		}
	}

	defer lock.Unlock()

	newFileBytes := []byte{}

	// read the authorized key file
	fileBytes, err := os.ReadFile(filePath)
	if err != nil {
		return fmt.Errorf("failed to read from authorized_keys file \"%s\": %s", filePath, err)
	}

	// iterate over the lines in our file, each line presents a new authorized_key entry
	scanner := bufio.NewScanner(bytes.NewReader(fileBytes))
	for scanner.Scan() {
		key := scanner.Text()

		// remove it if it's our current key, even if it's unexpired
		if key == currentKey {
			continue
		} else if strings.Contains(key, "created_at=") {
			// parse our creation time
			creationTimeString := strings.Split(strings.Split(key, "created_at=")[1], " ")[0]
			if creationTimeInt, err := strconv.ParseInt(creationTimeString, 10, 64); err != nil {
				// By returning here, we are opting not to overwrite the file at all.
				// This potentially leaves it around for longer but mitigates the risk of accidentally erasing something important
				return fmt.Errorf("malformated unix time")
			} else {
				unixCreationTime := time.Unix(0, creationTimeInt)

				// if the key is expired, remove it
				if time.Since(unixCreationTime) >= a.keyLifetime {
					continue
				}
			}
		}

		// scanner.Scan removed new line so we add that back in
		newLine := append(scanner.Bytes(), "\n"...)
		newFileBytes = append(newFileBytes, newLine...)
	}

	if err := scanner.Err(); err != nil {
		return err
	}

	// write our new file
	if err := os.WriteFile(filePath, newFileBytes, 0666); err != nil {
		return err
	}
	return nil
}

func (a *AuthorizedKeys) addKeyToFile(filePath string, contents string) error {
	// wait to acquire a lock on the authorized_keys file
	lock, err := a.lockService.NewLock()
	if err != nil {
		return fmt.Errorf("failed to obtain lock: %s", err)
	}
	for {
		if acquiredLock, err := lock.TryLock(); err != nil {
			return fmt.Errorf("error acquiring lock: %s", err)
		} else if acquiredLock {
			break
		}
	}

	defer lock.Unlock()

	// if the file doesn't exist, create it, or append to the file
	file, err := os.OpenFile(filePath, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		return err
	}
	defer file.Close()

	// make sure we're always writing our keys to new lines
	if fileBytes, err := os.ReadFile(filePath); err != nil {
		return err
	} else if len(fileBytes) > 0 && !strings.HasSuffix(string(fileBytes), "\n") {
		contents = "\n" + contents
	}

	if _, err := file.WriteString(contents); err != nil {
		return err
	}

	return nil
}
