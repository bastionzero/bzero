package authorizedkeys

import (
	"bufio"
	"bytes"
	"encoding/base64"
	"fmt"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	"bastionzero.com/bctl/v1/bzerolib/logger"
	"bastionzero.com/bctl/v1/bzerolib/services/fileservice"
	"bastionzero.com/bctl/v1/bzerolib/services/userservice"
)

const (
	maxKeyLifetime       = 30 * time.Second
	authorizedKeyComment = "bzero-temp-key"
)

func New(
	logger *logger.Logger,
	doneChan chan struct{},
	user string,
	pubkey string,
	fileService fileservice.FileService,
	userService userservice.UserService,
) error {
	// build authorized key entry in the right format then add it to the file
	if entry, err := buildAuthorizedKey(pubkey); err != nil {
		return err
	} else if filePath, err := buildFilePath(user, fileService, userService); err != nil {
		return err
	} else if err := fileService.Append(filePath, entry+"\n"); err != nil {
		return fmt.Errorf("failed to add key to authorized_keys file: %s", err)
	} else {

		// remove the key since it's ephemeral
		go func() {
			select {
			case <-doneChan:
			case <-time.After(maxKeyLifetime):
			}

			if err := cleanAuthorizedKeys(user, filePath, entry, fileService, logger); err != nil {
				logger.Errorf("Failed to remove old keys from %s's authorized_keys file: %s", user, err)
			}
		}()
	}

	return nil
}

func buildFilePath(user string, fileService fileservice.FileService, userService userservice.UserService) (string, error) {
	usr, err := userService.Lookup(user)
	if err != nil {
		return "", fmt.Errorf("failed to determine whether user exists: %s", err)
	} else if usr.HomeDir == "" {
		return "", fmt.Errorf("cannot connect as user without home directories")
	} else if err := fileService.MkdirAll(filepath.Join(usr.HomeDir, ".ssh"), os.ModePerm); err != nil {
		return "", fmt.Errorf("failed to create %s/.ssh/: %s", usr.HomeDir, err)
	} else {
		return filepath.Join(usr.HomeDir, ".ssh", "authorized_keys"), nil
	}
}

func buildAuthorizedKey(pubkey string) (string, error) {
	// Construct the authorized key entry
	// Assumes for now only ssh-rsa key types will be generated by the client so we do not need to validate the key type
	keyData := strings.Fields(pubkey)
	if len(keyData) < 2 {
		return "", fmt.Errorf("malformed public key")
	}

	keyType := keyData[0]
	keyContents := keyData[1]

	// test that the provided public key is valid base64 data
	if _, err := base64.StdEncoding.DecodeString(keyContents); err != nil {
		return "", fmt.Errorf("invalid public key provided: %s", keyContents)
	}

	timestamp := time.Now().UnixNano()
	key := fmt.Sprintf("%s %s %s created_at=%d", keyType, keyContents, authorizedKeyComment, timestamp)
	return key, nil
}

func cleanAuthorizedKeys(user string, filePath string, currentKey string, fileService fileservice.FileService, logger *logger.Logger) error {
	fileLock := authorizedFileLock{
		User: user,
	}

	// acquire a lock around the authorized keys file
	fileLock.Get()
	defer fileLock.Release()

	newFileBytes := []byte{}

	// read the authorized key file
	fileBytes, err := fileService.ReadFile(filePath)
	if err != nil {
		return fmt.Errorf("failed to read from authorized_keys file \"%s\": %s", filePath, err)
	}

	// iterate over the lines in our file, each line presents a new authorized_key entry
	scanner := bufio.NewScanner(bytes.NewReader(fileBytes))
	for scanner.Scan() {
		key := scanner.Text()

		// remove it if it's our current key, even if it's unexpired
		if key == currentKey {
			continue
		} else if strings.Contains(key, "created_at=") {
			// parse our creation time
			creationTimeString := strings.Split(strings.Split(key, "created_at=")[1], " ")[0]
			if creationTimeInt, err := strconv.ParseInt(creationTimeString, 10, 64); err != nil {
				return fmt.Errorf("malformated unix time")
			} else {
				unixCreationTime := time.Unix(0, creationTimeInt)

				// if the key is expired, remove it
				if time.Since(unixCreationTime) >= maxKeyLifetime {
					continue
				}
			}
		}

		// scanner.Scan removed new line so we add that back in
		newLine := append(scanner.Bytes(), "\n"...)
		newFileBytes = append(newFileBytes, newLine...)
	}

	if err := scanner.Err(); err != nil {
		return err
	}

	// write our new file
	if err := fileService.WriteFile(filePath, newFileBytes, 0666); err != nil {
		return err
	}
	return nil
}
