package authorizedkeys

import (
	"bufio"
	"bytes"
	"encoding/base64"
	"fmt"
	"os"
	"os/user"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
	"syscall"
	"time"

	"bastionzero.com/bctl/v1/bzerolib/filelock"
	"bastionzero.com/bctl/v1/bzerolib/logger"
)

const (
	authorizedKeyComment  = "bzero-temp-key"
	lockFileName          = "bz-lock.lock"
	authorizedKeyFileName = "authorized_keys"
)

type AuthorizedKeys struct {
	logger   *logger.Logger
	doneChan chan struct{}

	keyLifetime time.Duration

	keyFilePath string
	fileLock    *filelock.FileLock
}

func New(logger *logger.Logger, username string, doneChan chan struct{}, authKeyFolder string, lockFileFolder string, keyLifetime time.Duration) (*AuthorizedKeys, error) {

	if err := validateUsername(username); err != nil {
		return nil, err
	} else if usr, err := user.Lookup(username); err != nil {
		return nil, fmt.Errorf("failed to determine whether user exists: %s", err)
	} else if usr.HomeDir == "" {
		return nil, fmt.Errorf("cannot connect as user without home directories")
	} else if ok, err := checkDirPermissions(usr.HomeDir, usr); err != nil {
		return nil, err
	} else if !ok {
		return nil, fmt.Errorf("user %s does not have permission to edit dir: %s", username, usr.HomeDir)
	} else if keyFilePath, err := buildKeyFilePath(usr.HomeDir, authKeyFolder); err != nil {
		return nil, err
	} else if fileLock, err := createFileLock(usr.HomeDir, lockFileFolder); err != nil {
		return nil, err
	} else {
		return &AuthorizedKeys{
			logger:      logger,
			doneChan:    doneChan,
			fileLock:    fileLock,
			keyLifetime: keyLifetime,
			keyFilePath: keyFilePath,
		}, nil
	}
}

func (a *AuthorizedKeys) Add(pubkey string) error {
	// build authorized key entry in the right format then add it to the file
	if entry, err := a.buildAuthorizedKey(pubkey); err != nil {
		return err
	} else if err := a.addKeyToFile(entry); err != nil {
		return fmt.Errorf("failed to add key to authorized_keys file: %s", err)
	} else {

		// remove the key since it's ephemeral
		go func() {
			select {
			case <-a.doneChan:
				a.logger.Infof("Detected a closed done chan, cleaning authorized keys file")
			case <-time.After(a.keyLifetime):
				a.logger.Infof("SSH key expired, cleaning authorized keys file")
			}

			if err := a.cleanAuthorizedKeys(entry); err != nil {
				a.logger.Errorf("Failed to remove old keys from %s: %s", a.keyFilePath, err)
			}
		}()
	}

	return nil
}

func (a *AuthorizedKeys) buildAuthorizedKey(pubkey string) (string, error) {
	// Construct the authorized key entry
	// Assumes for now only ssh-rsa key types will be generated by the client so we do not need to validate the key type
	keyData := strings.Fields(pubkey)
	if len(keyData) < 2 {
		return "", fmt.Errorf("malformed public key")
	}

	keyType := keyData[0]
	keyContents := keyData[1]

	// test that the provided public key is valid base64 data
	if _, err := base64.StdEncoding.DecodeString(keyContents); err != nil {
		return "", fmt.Errorf("invalid public key provided: %s", keyContents)
	}

	timestamp := time.Now().UnixNano()
	key := fmt.Sprintf("%s %s %s created_at=%d", keyType, keyContents, authorizedKeyComment, timestamp)
	return key, nil
}

func (a *AuthorizedKeys) addKeyToFile(contents string) error {
	// wait to acquire a lock on the authorized_keys file
	lock, err := a.fileLock.NewLock()
	if err != nil {
		return fmt.Errorf("failed to obtain lock: %s", err)
	}
	for {
		if acquiredLock, err := lock.TryLock(); err != nil {
			return fmt.Errorf("error acquiring lock: %s", err)
		} else if acquiredLock {
			break
		}
	}

	defer lock.Unlock()

	// if the file doesn't exist, create it, or append to the file
	file, err := os.OpenFile(a.keyFilePath, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		return err
	}
	defer file.Close()

	// make sure we're always writing our keys to new lines
	if fileBytes, err := os.ReadFile(a.keyFilePath); err != nil {
		return err
	} else if len(fileBytes) > 0 && !strings.HasSuffix(string(fileBytes), "\n") {
		contents = "\n" + contents
	}

	if _, err := file.WriteString(contents); err != nil {
		return err
	}

	return nil
}

func (a *AuthorizedKeys) cleanAuthorizedKeys(currentKey string) error {
	// wait to acquire a lock on the authorized_keys file
	lock, err := a.fileLock.NewLock()
	if err != nil {
		return fmt.Errorf("failed to obtain lock: %s", err)
	}
	for {
		if acquiredLock, err := lock.TryLock(); err != nil {
			return fmt.Errorf("error acquiring lock: %s", err)
		} else if acquiredLock {
			break
		}
	}

	defer lock.Unlock()

	newFileBytes := []byte{}

	// read the authorized key file
	fileBytes, err := os.ReadFile(a.keyFilePath)
	if err != nil {
		return fmt.Errorf("failed to read from authorized_keys file \"%s\": %s", a.keyFilePath, err)
	}

	// iterate over the lines in our file, each line presents a new authorized_key entry
	scanner := bufio.NewScanner(bytes.NewReader(fileBytes))
	for scanner.Scan() {
		key := scanner.Text()

		// remove it if it's our current key, even if it's unexpired
		if key == currentKey {
			continue
		} else if strings.Contains(key, authorizedKeyComment) && strings.Contains(key, "created_at=") {
			// parse our creation time
			creationTimeString := strings.Split(strings.Split(key, "created_at=")[1], " ")[0]
			if creationTimeInt, err := strconv.ParseInt(creationTimeString, 10, 64); err != nil {
				// By returning here, we are opting not to overwrite the file at all.
				// This potentially leaves it around for longer but mitigates the risk of accidentally erasing something important
				return fmt.Errorf("malformated unix time")
			} else {
				unixCreationTime := time.Unix(0, creationTimeInt)

				// if the key is expired, remove it
				if time.Since(unixCreationTime) >= a.keyLifetime {
					continue
				}
			}
		}

		// scanner.Scan removed new line so we add that back in
		newLine := append(scanner.Bytes(), "\n"...)
		newFileBytes = append(newFileBytes, newLine...)
	}

	if err := scanner.Err(); err != nil {
		return err
	}

	// write our new file
	if err := os.WriteFile(a.keyFilePath, newFileBytes, 0666); err != nil {
		return err
	}
	return nil
}

// test that the provided username is valid unix user name
// source: https://unix.stackexchange.com/a/435120
func validateUsername(username string) error {
	usernamePattern := "^[a-z_]([a-z0-9_-]{0,31}|[a-z0-9_-]{0,30}\\$)$"
	var usernameMatch, _ = regexp.MatchString(usernamePattern, username)
	if !usernameMatch {
		return fmt.Errorf("invalid username provided: %s", username)
	}
	return nil
}

// validate that the user has a home directory, drop down to their permissions, and create authorized_keys if not exists
func buildKeyFilePath(homeDir string, keyFolder string) (string, error) {
	if err := os.MkdirAll(filepath.Join(homeDir, keyFolder), os.ModePerm); err != nil {
		return "", fmt.Errorf("failed to create %s/%s/: %s", homeDir, keyFolder, err)
	} else {
		return filepath.Join(homeDir, keyFolder, authorizedKeyFileName), nil
	}
}

func createFileLock(homeDir string, lockFileFolder string) (*filelock.FileLock, error) {
	if err := os.MkdirAll(filepath.Join(homeDir, lockFileFolder), os.ModePerm); err != nil {
		return nil, fmt.Errorf("failed to create %s/%s/: %s", homeDir, lockFileFolder, err)
	} else {
		return filelock.NewLockService(filepath.Join(homeDir, lockFileFolder, lockFileName)), nil
	}
}

// This function checks to see whether a user has permissions to create a file in a directory. It
// mimics the permission checking process undertaken by the kernel and as dictated by Advanced
// Programming in the Unix Environment Third Edition by W. Richard Stevens and Stephen A. Rago
// (p. 101).
//
// In order to make sure we can create files in a directory, we need to check that the user has both
// write and execute permissions.
//
// Permission validation process:
// 1. if user's uid is 0 (aka "root"), then it can do whatever it wants
// 2. if user's uid is the same as the owner of the file, check for access perms, else reject access
// 3. if any of the user's gids matches the gid of the file, check for access perms, else reject access
// 4. check if any other user is allowed to do what we want, else reject
//
// These steps are taken in sequence, if you're the owner and you don't have the right permissions, we don't
// fall back onto group logic, etc.
//
// FileInfo mode comes in format "drwxrwxrwx" always:
// https://cs.opensource.google/go/go/+/refs/tags/go1.18.2:src/io/fs/fs.go;drc=2580d0e08d5e9f979b943758d3c49877fb2324cb;bpv=1;bpt=1;l=194?gsn=String&gs=kythe%3A%2F%2Fgo.googlesource.com%2Fgo%3Flang%3Dgo%3Fpath%3Dio%2Ffs%23method%2520FileMode.String
func checkDirPermissions(path string, usr *user.User) (bool, error) {
	info, err := os.Stat(path)
	if err != nil {
		return false, fmt.Errorf("path does not exist")
	} else if !info.IsDir() {
		return false, fmt.Errorf("path isn't a directory")
	} else if info.Sys() == nil {
		return false, fmt.Errorf("unable to retrieve directory owner or group")
	}

	// check if user is root or the directory owner
	fileUID := info.Sys().(*syscall.Stat_t).Uid
	if uid, err := strconv.Atoi(usr.Uid); err != nil {
		return false, fmt.Errorf("failed to convert user string GID to int: %s", err)
	} else if uid == 0 { // if you're root, you can do anything
		return true, nil
	} else if uint32(uid) == fileUID { // if directory owner is user
		// check that owner has write and execute permissions
		ownerWrite := string(info.Mode().String()[2])
		ownerExecute := string(info.Mode().String()[3])
		if ownerWrite == "w" && ownerExecute == "x" {
			return true, nil
		} else {
			// no second chances
			return false, nil
		}
	}

	// check to see if directory belongs to any group that the user is in
	fileGID := info.Sys().(*syscall.Stat_t).Gid
	if gids, err := usr.GroupIds(); err != nil {
		return false, fmt.Errorf("failed to get user groups: %s", err)
	} else {
		for _, gid := range gids {
			if gidInt, err := strconv.Atoi(gid); err != nil {
				return false, fmt.Errorf("failed to convert user string GID to int: %s", err)
			} else if uint32(gidInt) == fileGID {
				// check if group has write and execute permissions
				groupWrite := string(info.Mode().String()[5])
				groupExecute := string(info.Mode().String()[6])
				if groupWrite == "w" && groupExecute == "x" {
					return true, nil
				} else {
					// no second chances
					return false, nil
				}
			}
		}
	}

	// check to see if anyone can write to the directory
	othersWrite := string(info.Mode().String()[8])
	othersExecute := string(info.Mode().String()[9])
	if othersWrite == "w" && othersExecute == "x" {
		return true, nil
	} else {
		return false, nil
	}
}
